<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on porschiey&#39;s dev.blog</title>
        <link>https://dev.porschiey.io/posts/</link>
        <description>Recent content in Posts on porschiey&#39;s dev.blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 13 Oct 2025 18:12:18 -0600</lastBuildDate>
        <atom:link href="https://dev.porschiey.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Building a world that never sleeps</title>
            <link>https://dev.porschiey.io/posts/building-world-never-sleeps/</link>
            <pubDate>Sat, 11 Oct 2025 08:22:27 -0600</pubDate>
            
            <guid>https://dev.porschiey.io/posts/building-world-never-sleeps/</guid>
            <description>&lt;p&gt;&lt;del&gt;Keep it simple for your first game&lt;/del&gt;. For quite some time I&amp;rsquo;ve been pondering a new multiplayer server technology and netcode architecture. After spending 15+ years in the gaming industry I know this is no small task - there&amp;rsquo;s a graveyard of game studios and aspirational game devs alike who have tried and failed to write good netcode. In fact, I was at a &lt;a href=&#34;https://starform.co&#34;&gt;startup&lt;/a&gt; that was plagued with network issues that they spent loads of money and manpower (myself included) to figure it out.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><del>Keep it simple for your first game</del>. For quite some time I&rsquo;ve been pondering a new multiplayer server technology and netcode architecture. After spending 15+ years in the gaming industry I know this is no small task - there&rsquo;s a graveyard of game studios and aspirational game devs alike who have tried and failed to write good netcode. In fact, I was at a <a href="https://starform.co">startup</a> that was plagued with network issues that they spent loads of money and manpower (myself included) to figure it out.</p>
<p>But I wouldn&rsquo;t be writing this devblog if I hadn&rsquo;t 1) had a plan and 2) already got it working. (:</p>
<p>I know what you&rsquo;re thinking. It&rsquo;s ambitious to come up with a new networking/server topology for my first indie game, but it&rsquo;s definitely the only complicated or big idea I&rsquo;m throwing into my first game, I swear. Except for the custom proceedural generation&hellip; oh and inventing a new art style without being an artist&hellip; and a few other things we won&rsquo;t mention here. Yet.</p>
<p>But here&rsquo;s hoping my career experience will give me a leg up here. Oh right&hellip; given this is my first blog post, I should probably introduce myself.</p>
<h3 id="whoami">whoami</h3>
<p>My name is Brandon - alias: Porschiey. I wrote my first website by hand in HTML w/ the help of my dad in 1998. Since then the most important thing I&rsquo;ve learned is that <em>the only <code>constant</code> is <code>change</code></em>, and that I must keep a student mindset, or I risk being left behind. Perhaps in another post I can detail my career in more detail, but the short version is that I spent time freelancing, then at Xbox, Azure, a large game studio (343 Industries), a small game studio (Starform), and now I&rsquo;m back at Xbox yet again working on emerging technologies. And on the side, I am working on a new indie game called &ldquo;Parchment&rdquo; - a 4X persistent world fantasy game.</p>
<h3 id="where-were-we">where were we?</h3>
<p>Oh yeah that&rsquo;s right, a new game server / multiplayer / netcode design. Well, if I&rsquo;m honest, I&rsquo;m not quite sure if it&rsquo;s new - I&rsquo;ve not been to every single game studio and asked them about their (probably secret) proprietary tech. It&rsquo;s likely more accurately described as a collection of patterns, practices and ideas from different systems I&rsquo;ve seen in the past 15+ years. I will be attempting to explain how it all works <em>generally</em>, without getting too technical, in the hopes of keeping a wider reading audience but also to keep some secret sauce for myself.</p>
<h2 id="simulations-that-arent-transient">simulations that aren&rsquo;t transient</h2>
<p>When you play a traditional RTS or 4X game, the world exists only while you’re in it. You log out, the simulation stops, and the universe blinks out of existence until you return. Parchment isn’t like that. Every realm keeps ticking — even when you’re offline — evolving under the stewardship of both human and AI civilizations.</p>
<p>Designing that kind of persistence meant building a server model closer to an MMO, but one tuned for asynchronous strategy, not 100% twitch combat.</p>
<h3 id="introducing-your-personal-bee">introducing your personal &ldquo;bee&rdquo;</h3>
<p>When you join a realm, your own personal &ldquo;bee&rdquo; spawns in the hive of bees. This bee takes in all of your requests, validates them, does most of the heavy compute work, and ensures all your input is handled sequentially or in order. It is not bothered by what the other bees are doing, and it will always go to a honeycomb that is least busy. (For the technical folks out there, this is the <a href="https://learn.microsoft.com/en-us/dotnet/orleans/overview">Orleans Grains/Silo technology</a>, aka Actor Model).</p>
<p>When the bee has finished a unit of work, it delivers it to the queen bee, who in turn distributes information about that unit of work to any others that care. In this way, the queen is in charge of the realm. This &ldquo;actor model&rdquo; concept isn&rsquo;t a new thing in the software industry, but something that&rsquo;s rather special about how I&rsquo;m doing it is how seemlessly and quickly it scales.</p>
<p><img src="/images/beeHiveServers.png" alt=""></p>
<p>As you can see, for any given realm that&rsquo;s running, the work is spread over multiple servers. This gives us several wins:</p>
<ol>
<li>A &ldquo;hot&rdquo; realm is never on one server alone. &ldquo;Cold&rdquo; realms automatically make space for the hot ones.</li>
<li>A simulation error or issue doesn&rsquo;t have to crash the realm, just your worker bee. Most game servers have one ferociously pumping update loop that any one single exception can bring the entire thing crashing down.</li>
<li>The primary &ldquo;update loop&rdquo; is automatically multi-threaded across several servers and doesn&rsquo;t have to be concerned with large compute or physics tasks like pathfinding or terrain generation.</li>
</ol>
<h3 id="multiplayer-games-are-classicly-very-chatty">multiplayer games are classicly very &ldquo;chatty&rdquo;</h3>
<p>The standard issue multiplayer dedicated server is noisy and busy. <em>Every single frame of the simulation</em> the server is sending updates about the game (typically game state or partial state updates) to every connected player. At a 20FPS simulation with 10 connected clients sending input, the server is sending/receiving hundreds (often thousands) of events over the network per second. Granted, this is a mediocre design scenario, many modern designs are better than this - but even the best ones are transmitting hundreds of updates per second for only ten players.</p>
<p>Rather than flooding the network with constant position updates like a shooter, Parchment communicates in orders, not transforms. For example, the client sends a “move to” command; the server validates, computes a path, and sends back waypoints. The client then interpolates locally and reconciles occasionally.</p>
<p>Bandwidth is tight and tidy. A single move command takes a fraction of what it would in a typical multiplayer persistent world server. World of Warcraft, for example, clocks in at 21KB/s per player average according to this <a href="https://lucris.lub.lu.se/ws/portalfiles/portal/5535189/2027067.pdf">academic source</a> (and that&rsquo;s fairly low). <em>Parchment will hopefully sit between 0.5KB/s or 1.5KB/s.</em></p>
<p>This opens up so many exciting possibilities:</p>
<ol>
<li>Parchment as a mobile game isn&rsquo;t going to frustrate players for consuming mobile data</li>
<li>More realms can fit onto a single server, drastically reducing costs to maintain realms. The current ambitious goal is to have a single server have the capability to serve 10,000 concurrent players (100x realms per server, 100 players per realm). Web servers can do this easily, but game servers&hellip; I rarely see a single game server (VM) that host more than 1000 players. (In fairness, some notable callouts that can include Minecraft, PlanetSide).</li>
</ol>
<h3 id="i-havent-even-covered-some-of-the-best-parts">I haven&rsquo;t even covered some of the best parts</h3>
<p>That&rsquo;s all for now&hellip; this blog is now getting a little long, so I&rsquo;ll save some of the more interesting parts for next time. (:</p>
<p>Next up:</p>
<ul>
<li>Keeping time in a persistent world</li>
<li>Fast-fowarding and parking</li>
<li>Snapshots &amp; per-realm upgrades</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
