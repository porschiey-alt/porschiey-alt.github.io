<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on porschiey&#39;s dev.blog</title>
        <link>https://dev.porschiey.io/posts/</link>
        <description>Recent content in Posts on porschiey&#39;s dev.blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 08 Jan 2026 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://dev.porschiey.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Parchment DevBlog #2</title>
            <link>https://dev.porschiey.io/posts/devblog2/</link>
            <pubDate>Thu, 08 Jan 2026 00:00:00 +0000</pubDate>
            
            <guid>https://dev.porschiey.io/posts/devblog2/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;https://dev.porschiey.io/images/combatExample.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Over the holidays we spent quite a lot of our free time &lt;del&gt;playing Dungeons &amp;amp; Dragons&lt;/del&gt; working on Parchment, and we&amp;rsquo;ve officially got a build that friends and family can play! If you&amp;rsquo;d like access, feel free to stop by our &lt;a href=&#34;https://discord.gg/hmhgbsUPd5&#34;&gt;Discord Server&lt;/a&gt; and say hi. Be warned, the alpha is rough around the edges and has it&amp;rsquo;s share of bugs - but that&amp;rsquo;s what it is for. This update will detail the features in the alpha and the work we accomplished to get there.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/combatExample.gif" alt=""></p>
<p>Over the holidays we spent quite a lot of our free time <del>playing Dungeons &amp; Dragons</del> working on Parchment, and we&rsquo;ve officially got a build that friends and family can play! If you&rsquo;d like access, feel free to stop by our <a href="https://discord.gg/hmhgbsUPd5">Discord Server</a> and say hi. Be warned, the alpha is rough around the edges and has it&rsquo;s share of bugs - but that&rsquo;s what it is for. This update will detail the features in the alpha and the work we accomplished to get there.</p>
<h2 id="battles">BATTLES!</h2>
<p>We&rsquo;ve refactored our combat system (or rather, actually created it) such that it is no longer the standard RTS &ldquo;unit attacks other unit on the screen&rdquo;, but instead it will feel a bit more like what you&rsquo;d see in Stellaris, where a battle takes place that produces artifacts. In our case, it&rsquo;s loot! (See the LOOT! section). This battle system will be one of the primary fun mechanisms in the game, so we&rsquo;re spending a lot of time on it. It&rsquo;s still quite rough around the edges, and there&rsquo;s certainly a lot of work left before we release a demo, but here&rsquo;s a sneak peak of the different battle states you can get into:</p>
<p><img src="/images/battleIconsWatermarked.png" alt=""></p>
<h2 id="loot">LOOT!</h2>
<p>After a battle completes, both the victor and the loser(s) can view the results, and collect some items. The victor will receive a majority of the loot - typically gold, food, and other supplies depending on what they&rsquo;ve attacked. The loser(s) will be able to recover a little bit of what they had left. In the coming weeks, when we add the full functionality to attack buildings, you&rsquo;ll be able to raid cities and get grander prizes. Be warned though, the farther away you are from your own territory, the more costly things will get.</p>
<p>Right now, the best way to get gold in the game is to battle other players - at least until we add the gold mine!</p>
<h2 id="mountains-well-lines">Mountains. Well, lines.</h2>
<p>We&rsquo;ve made some huge code progress and minor visual progress on the drawing of mountains. One will notice as they enter the game, mountain ridges starting to be drawn onto the map. This is the beginning of a new mountain driver that will hopefully draw beautiful mountains onto your map. After they&rsquo;re in place, it will be tougher for your units to go through the mountains (slower speed) - and we&rsquo;ll do something similar for water.</p>
<h4 id="getting-technical">Getting technical&hellip;</h4>
<p>The new mountain driver is quite exciting. For those technical, here&rsquo;s essentially how it works.</p>
<ol>
<li>Import a height map of the terrain from the server.</li>
<li>Run a custom built &ldquo;peak finder&rdquo; algorithm that finds all the tallest peaks in the mountain range from the height map.</li>
<li>Curate those peaks so that they seem legitimate.</li>
<li>Draw connections between peaks that are close enough to each other, to create potential ridges.</li>
<li>Draw mountain ridge lines with jitter (pre-baked seed so everyone sees the same)</li>
</ol>
<p>In the end, it&rsquo;s a TON of math, as you can imagine, and a bit brutal to test, but here&rsquo;s what it looks like inside Unity - we&rsquo;ve added some &ldquo;Gizmos&rdquo; to draw the connection lines for ridges:</p>
<p><img src="/images/mountainGizmos.png" alt=""></p>
<p>Next, we&rsquo;ll draw the rest of the mountain lines that spawn from those ridges, so stay tuned!</p>
<h2 id="bots-make-the-world-feel-alive">Bots make the world feel alive</h2>
<p>We&rsquo;ve added some &ldquo;starter bots&rdquo; to the game, managed by the realm. Right now they don&rsquo;t attack - just spawn a few units and do lots of research. Soon though, we&rsquo;ll be adding some bot profiles:</p>
<ul>
<li>Peaceful - These won&rsquo;t attack you, making them easy raid targets.</li>
<li>Easy - Likely nearby, might send a scout or two over to take you on.</li>
<li>Average - On the outskirts of your spawn. They&rsquo;ll be sure to want to take your territory.</li>
<li>Tough - On the frontier. These will not give up their land easily, and will strike back with power once you discover them.</li>
<li>Brutal - These are meant to play like players. They will expand and try to conquer everything they see.</li>
</ul>
<p>Right now, all the bots are essentially on Peaceful, and we spawn about 8-10 bots per real player connected to the realm.</p>
<h4 id="thats-all-for-now">That&rsquo;s all for now</h4>
<p>We&rsquo;ll make another progress update next month!</p>
]]></content>
        </item>
        
        <item>
            <title>Parchment DevBlog #1</title>
            <link>https://dev.porschiey.io/posts/devblog1/</link>
            <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
            
            <guid>https://dev.porschiey.io/posts/devblog1/</guid>
            <description>&lt;p&gt;Hello all! I&amp;rsquo;m considering this the first official project update for Parchment - and there&amp;rsquo;s a lot to update since my last technical blog in October. We&amp;rsquo;ve got some new art to show, team growth to highlight, and some goals to share. I hope to make a monthly post to share the progress made, even if I&amp;rsquo;m sending this out to the void with very little readership. &amp;lt;3&lt;/p&gt;
&lt;h1 id=&#34;shiny-new-icons&#34;&gt;Shiny new icons&lt;/h1&gt;
&lt;p&gt;First up, I&amp;rsquo;ve hired an artist to do some freelance work for the game, starting with our resource icons in the game:&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>Hello all! I&rsquo;m considering this the first official project update for Parchment - and there&rsquo;s a lot to update since my last technical blog in October. We&rsquo;ve got some new art to show, team growth to highlight, and some goals to share. I hope to make a monthly post to share the progress made, even if I&rsquo;m sending this out to the void with very little readership. &lt;3</p>
<h1 id="shiny-new-icons">Shiny new icons</h1>
<p>First up, I&rsquo;ve hired an artist to do some freelance work for the game, starting with our resource icons in the game:</p>
<p><img src="/images/zevIcons.png" alt=""></p>
<p>Credit: <a href="https://www.behance.net/zevxavier1">Zev</a></p>
<p>Breaking down these icons, we see from left to right&hellip;</p>
<ul>
<li>Wood: Abundant early game resource for construction</li>
<li>Food: Abundant Early game resource for units and research</li>
<li>Stone: Early-Mid game resource for construction</li>
<li>Gold: Mid-game resource that has wide usage</li>
<li>Obsidian: Rare late-game resource for special upgrades</li>
<li>Aether: Rare late-game resource for magical upgrades</li>
</ul>
<p>I wonder where in the generated world one can find all of these resources&hellip;</p>
<h1 id="solo---duo">Solo -&gt; Duo</h1>
<img src="/images/cheeselogAv.webp" style="float:left; padding-right: 10pt;" />
<p>Great news! Another developer (and friend) has decided to jump in and help here and there! Meet <strong>Cheeselog</strong>, the second official team member! Although technical in other ways, he is an aspirant when it comes to game development so I&rsquo;ve taken him on as a junior developer in a learning capacity. He&rsquo;s already fixed one bug! Feel free to stop by our <a href="https://discord.gg/hmhgbsUPd5">Discord Server</a> and say hi.</p>
<p>The team growing from one to 1+ means something significant. We&rsquo;re essentially a non-funded startup, and we&rsquo;ll have to come up with a studio name. Exciting times!</p>
<h1 id="decembers-goal">December&rsquo;s Goal</h1>
<p>Our goal for December is to launch a test realm in the cloud. Each realm will have it&rsquo;s own name, similar to that of MMO game servers. This one we&rsquo;re calling <strong><code>Hightower</code></strong> The naming scheme for the Realm will be taken from a Dungeons &amp; Dragons table I am the DM for. In fact, we have officially gotten our hands on a couple of Unity Build machines that we&rsquo;ve named after characters in that DnD table. This test realm won&rsquo;t be very feature rich, but instead places weight on ensuring all the network pieces are operating which is critical. This also means we have to spin up our build pipelines (and the before-mentioned build machines), get things deployed to the cloud, and iron out all the kinks to get us from code-written -&gt; game-playable. I&rsquo;ve added a &ldquo;Technical section&rdquo; below for those who might want to read up on what we&rsquo;ve done so far to accomplish this. The <code>Hightower</code> realm will not be accessible to the general public yet, released on Steam or anything of that nature, but instead internally to trusted friends. Eventually however, we hope for <code>Hightower</code> to be the &ldquo;PTR&rdquo; - Public Test Realm. Perhaps in early Spring of 2026.</p>
<h2 id="the-technical-bits-deploying-ci-and-more">The Technical Bits, Deploying, CI, and more</h2>
<p>In my experience, when you&rsquo;re building out a server/client system from scratch - the longer you wait to actually decouple them from the local machine and deploy the service to connect to a stand-alone client, the more technical debt you acquire. Some of it is unknown to you, but either way one shoves it aside as if they&rsquo;ll be simple to handle later.</p>
<blockquote>
<p>I need an additional datastore for this? That&rsquo;s fine, the local database emulator can handle it. I need to save files in the cloud? I&rsquo;ll save them locally for now.</p>
</blockquote>
<p>Recently, I decided it was time to pause my feature development and dive into the operations side of house. Continuous Intergration pipelines so that every code check in automatically makes a new build. Deployments to a cloud test environment to begin fleshing out how a real server environment. All that sort of thing. This immediately meant two things:</p>
<h3 id="1-handling-all-of-my-local-only-implementations">1. Handling all of my &ldquo;local-only&rdquo; implementations</h3>
<h4 id="saving-generated-map-slices-locally">Saving Generated Map Slices Locally</h4>
<p>To get things jump started, every time we generated a new slice of the map, that slice was saved locally where the server ran. This immediately becomes an issue when:</p>
<ul>
<li>Many hosting platforms don&rsquo;t let you fill up the VM&rsquo;s hard drive (and nor should you, unless you can guarantee to get the same drive with a new VM)</li>
<li>Many VMs don&rsquo;t have large disks and many hosting solutions lean toward &ldquo;serverless&rdquo;, which is fancy for &ldquo;you can&rsquo;t manage the server underneath&rdquo;</li>
<li>Other servers don&rsquo;t have the same data and will have to get it themselves somehow.</li>
</ul>
<p>This is all not a huge deal for running our game in development mode locally, but in a cloud environment, it&rsquo;s a big deal. So, we converted all this to use Azure Blob Storage. It was an easy swap at the end of the day, since the bits that Get and Save slices are behind interfaces.</p>
<h4 id="short-running-instances">Short-running instances</h4>
<p>It&rsquo;s easy to wipe your local storage and start fresh every single time you run the game in development mode locally. A deployed server cluster is far more complicated. Recently I&rsquo;ve introduced shutdown and reset mechanisms that warn players of a realm shutdown, and then gracefully shutdown pieces of the &ldquo;beehive&rdquo; and drain connections from the server. Essentially, I&rsquo;ve introduced <code>Maintence Mode</code> so that we can pause data-streams for Realms while we deploy a new pod of servers, if we want, for example.</p>
<h3 id="2-handling-all-of-the-scale-out-landmines">2. Handling all of the &ldquo;scale-out&rdquo; landmines</h3>
<h4 id="orleans-landmine"><strong>Orleans Landmine</strong></h4>
<p>The beehive/grain structure detailed in other posts needs some special TLC to get working in a real server environment. There are very few offerings from Azure/AWS that are cheap but have limited support for all the special communications needed here. There are of course larger offerings, like Kubernetes, which come with the support for all the special communications, but depending on the region, require at least 2 two nodes at around $60 USD/month. I don&rsquo;t think I want my test environment this early in development to cost $120/month.</p>
<p>Luckily I was able to settle on some middle ground in Azure, using Azure App Services with special commands that unlock private ports in a Virtual Network. It&rsquo;s not an easy setup, but it&rsquo;s an affordable one that works. Having not read every single letter of the docs, I didn&rsquo;t know this was going to be a problem until I looked at the telemetry coming out of the server cluster:</p>
<p><img src="/images/orleansErrors.png" alt=""></p>
<p>Things were working, but I had effectively chopped up my &ldquo;beehive&rdquo; into two hives, as they could not communicate with each other. After researching a bunch and sleeping on it, you can see the next morning a new and improved deployment fixed the issue.</p>
<h4 id="signalr-landmine">SignalR Landmine</h4>
<p><a href="https://dotnet.microsoft.com/en-us/apps/aspnet/signalr">SignalR</a> is a realtime technology built on WebSockets that we&rsquo;re using to for server&lt;-&gt;client realtime communication. Players will essentially <em>bind</em> their connection to a particular server - that server becomes their broker of information.</p>
<blockquote>
<p>&ldquo;However, when you [add servers&hellip;], clients can get routed to different ones. A client that is connected to one server will not receive messages sent from another server.&rdquo;</p>
<p>-<a href="https://learn.microsoft.com/en-us/aspnet/signalr/overview/performance/scaleout-in-signalr">Scaleout in SignalR</a></p>
</blockquote>
<p>This can be a bad thing, especially if you&rsquo;re going for a more stateless approach (any server should be able to help you). If one server knows all your details and the others do not, you could get bad data talking to the wrong one. However, with the Beehive (Orleans), this actually is not a problem. Regardless of whatever server your bind to, your comms will be sent to the server that has <em>your</em> worker bee. This allows us to be stateful without needing a backplane for data understanding.</p>
<p>So for now, this landmine remains one we haven&rsquo;t stepped on. However, as the game potentially scales out further, we may have to look at <a href="https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview">SignalR Service</a>, which can handle thousands of connections at once and not bog down the connections to the primary servers.</p>
]]></content>
        </item>
        
        <item>
            <title>Building a world that never sleeps (part 2)</title>
            <link>https://dev.porschiey.io/posts/building-world-never-sleeps-2/</link>
            <pubDate>Tue, 14 Oct 2025 00:00:18 -0600</pubDate>
            
            <guid>https://dev.porschiey.io/posts/building-world-never-sleeps-2/</guid>
            <description>&lt;p&gt;We last left off in &lt;a href=&#34;https://dev.porschiey.io/posts/building-world-never-sleeps/&#34;&gt;part 1&lt;/a&gt; talking about how chatty multiplayer dedicated servers can be, and how we&amp;rsquo;ve got this &amp;ldquo;hive&amp;rdquo; system that powers and scales out the realms without being so chatty. But we never got to the no-sleep part, did we?&lt;/p&gt;
&lt;p&gt;When you log into Parchment, if you didn&amp;rsquo;t already have one, a worker bee spawns just for you. This &amp;ldquo;actor,&amp;rdquo; we will call it from here on out, persists after you sign out and helps answer questions about your civilization/empire/base when you&amp;rsquo;re not around.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>We last left off in <a href="/posts/building-world-never-sleeps/">part 1</a> talking about how chatty multiplayer dedicated servers can be, and how we&rsquo;ve got this &ldquo;hive&rdquo; system that powers and scales out the realms without being so chatty. But we never got to the no-sleep part, did we?</p>
<p>When you log into Parchment, if you didn&rsquo;t already have one, a worker bee spawns just for you. This &ldquo;actor,&rdquo; we will call it from here on out, persists after you sign out and helps answer questions about your civilization/empire/base when you&rsquo;re not around.</p>
<h3 id="persistent-worlds">Persistent worlds</h3>
<p>Because your actor hangs out after you&rsquo;re gone, your civilization can continue to grow, defend, and make automatic choices as well. It sends its authoritative choices to the queen bee and the world keeps moving on while you sleep. If you have resources that you&rsquo;re gathering, they continue to gather. If you have technologies you&rsquo;re researching, they continue to research. Your own actor keeps time and executes these actions because it has it&rsquo;s own &ldquo;update loop.&rdquo;</p>
<p>This internal update loop is something I&rsquo;m calling the economy tick. The tick runs at between 0.25hz and 2hz (Once every 4 seconds to twice a second), depending on the need and priority. This tick purposely competes with user input and does not interleave. <em>This means each tick of the economy loop per player is treated like a player input, which in turn means everything is processed in order as it should be.</em></p>
<h3 id="okay-yes-they-sometimes-nap">Okay, yes, they sometimes nap</h3>
<p>On occassion, realms may find that there is very little to do. This can happen when a player hasn&rsquo;t given much input recently, hasn&rsquo;t signed in for some time, and/or hasn&rsquo;t had their civilization interacted with by others in some time. <em>To save on server capacity, we &ldquo;park&rdquo; those inactive actors/bees until they are needed again.</em> When they reactivate, we fast-forward them to present day. This includes marking any resources as harvested (and adding them to the player&rsquo;s currency), as well as things like marking their technology researches complete. Ultimately these are all planned to be just math, so it shouldn&rsquo;t be compute heavy and fairly easy. But if needed, we can always burst some compute for the catch up.</p>
<h3 id="resiliency-and-beta-realms">Resiliency and beta-realms</h3>
<p>When a realm begins, it locks in several things:</p>
<ul>
<li>The randomization seeds for proceedural generation</li>
<li>The technology trees</li>
<li>The realm start and end time (realms are designed to last for a &ldquo;season&rdquo;)</li>
</ul>
<p>This means that we can effectively have each realm be it&rsquo;s own flavorful and unique experience. <em>There might be a realm that&rsquo;s more prone to oceans, one that limits technology, or even one that introduces a new technology as a &ldquo;beta realm.&rdquo;</em> Giving players the choice to further flavor their experience each time they play is something I&rsquo;ve baked into the server tech.</p>
<p>Because these configurations are baked into each realm at creation time but all use the same code framework to empower them, I can continiously upgrade the game on both the server and game.exe on players machines without needing everyone to be on the same version. The system is inheritly backwards compatiable, by design and from the start. Realms themselves can act as feature flags. This resiliency allows players to enjoy their &ldquo;playthrough&rdquo; without fear of design patches.</p>
<p>Bug patches, if needed, can be applied to realms however as well. The configuration data they&rsquo;ve snapshotted can always be altered if what is within is causing a bug. In addition to this abstract resiliency, there&rsquo;s obviously concrete ones as well. Every so often your actor and the realm&rsquo;s actor (queen bee) perform a snapshot and backup everything in case we need to restore to specific point in time. These backups are kept in a rolling window. The max size over time for a single realm becomes deterministic.</p>
<h3 id="scaling-in-three-dimensions">Scaling in three dimensions</h3>
<p>In the server-side industry, there&rsquo;s typically three kinds of ways to handle high volume:</p>
<ol>
<li>Scaling Up - Giving servers more power, more muscle. More memory, more vCPUs, etc.</li>
<li>Scaling Out - Adding more servers. The box we carry weighs less the more of us that carry it.</li>
<li>Writing Performant Software - How your code perfoms during unfathomable scale, how it protects itself, and how much it understands what you&rsquo;ve done for option 2 (multiple regions, shards, and so on.)</li>
</ol>
<p>Options 1 and 2 can be boiled down to a single option if you&rsquo;d like: &ldquo;Buying away the problem.&rdquo; Throw more money at it, it goes away - more servers and/or better ones. But unless you&rsquo;ve coded for having multiple servers to carry the same load, option 2 can be a nightmare. Most dedicated host game servers are stateful and self contained for this reason. They live on a single VM or piece of hardware, and they service one simulation at a time. If you have more players and more demand, you simply add more dedicated servers that can host a 5x5 player match. MMOs don&rsquo;t have that exact luxury and most be more intentional about executing option 2 by executing option 3 at the same time. They create shards and instances of responsibility, split up the work. You might be connected to a different game server if you&rsquo;re in different continent in the game.</p>
<p>Parchment&rsquo;s server design takes that even further. We split up the work down to each individual player, and spread it across the entire fleet of servers. Our &ldquo;dedicated server&rdquo; is not a single executable we throw onto a host VM that dies when a simulation ends. Our dedicated server is a series of logical and virtual nodes that exist across the entire fleet of cloud machines. Your realm might be ticking away in California while your worker bee/actor is ticking away in Texas and your rival is ticking away in Virginia. Queue the movie-esque globe network topology with nodes below.</p>
<p><img src="/images/worldNodes.png" alt=""></p>
<blockquote>
<p><em>Imagine if those nodes weren&rsquo;t dedicated servers&hellip; but instead&hellip; that entire picture is the dedicated server.</em></p>
</blockquote>
<p>Because the code is also written with high performance in mind (reduced backpressure, bulkhead partitioning, virtual circuit breakers, enforced timeouts, exponential backoff retry policies, negative caching, etc&hellip;) we can safely scale our fleet of servers with how busy the server is and everything else automatically expands. With less network I/O, we can host more realms on one &ldquo;box&rdquo; or machine, and therefore more players on that machine.</p>
<h3 id="okbye">okbye</h3>
<p>There&rsquo;s a lot of items I didn&rsquo;t cover - including gotchas and pitfalls for this approach, but for now that will conclude talking about the network/server design. Perhaps all of it could have been summarized into: &ldquo;My dedicated server is a hipster,&rdquo; or something. Oh well. ¯_(ツ)_/¯</p>
]]></content>
        </item>
        
        <item>
            <title>Building a world that never sleeps</title>
            <link>https://dev.porschiey.io/posts/building-world-never-sleeps/</link>
            <pubDate>Sat, 11 Oct 2025 08:22:27 -0600</pubDate>
            
            <guid>https://dev.porschiey.io/posts/building-world-never-sleeps/</guid>
            <description>&lt;p&gt;&lt;del&gt;Keep it simple for your first game&lt;/del&gt;. For quite some time I&amp;rsquo;ve been pondering a new multiplayer server technology and netcode architecture. After spending 15+ years in the gaming industry I know this is no small task - there&amp;rsquo;s a graveyard of game studios and aspirational game devs alike who have tried and failed to write good netcode. In fact, I was at a &lt;a href=&#34;https://starform.co&#34;&gt;startup&lt;/a&gt; that was plagued with network issues that they spent loads of money and manpower (myself included) to figure it out.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><del>Keep it simple for your first game</del>. For quite some time I&rsquo;ve been pondering a new multiplayer server technology and netcode architecture. After spending 15+ years in the gaming industry I know this is no small task - there&rsquo;s a graveyard of game studios and aspirational game devs alike who have tried and failed to write good netcode. In fact, I was at a <a href="https://starform.co">startup</a> that was plagued with network issues that they spent loads of money and manpower (myself included) to figure it out.</p>
<p>But I wouldn&rsquo;t be writing this devblog if I hadn&rsquo;t 1) had a plan and 2) already got it working. (:</p>
<p>I know what you&rsquo;re thinking. It&rsquo;s ambitious to come up with a new networking/server topology for my first indie game, but it&rsquo;s definitely the only complicated or big idea I&rsquo;m throwing into my first game, I swear. Except for the custom proceedural generation&hellip; oh and inventing a new art style without being an artist&hellip; and a few other things we won&rsquo;t mention here. Yet.</p>
<p>But here&rsquo;s hoping my career experience will give me a leg up here. Oh right&hellip; given this is my first blog post, I should probably introduce myself.</p>
<h3 id="whoami">whoami</h3>
<p>My name is Brandon - alias: Porschiey. I wrote my first website by hand in HTML w/ the help of my dad in 1998. Since then the most important thing I&rsquo;ve learned is that <em>the only <code>constant</code> is <code>change</code></em>, and that I must keep a student mindset, or I risk being left behind. Perhaps in another post I can detail my career in more detail, but the short version is that I spent time freelancing, then at Xbox, Azure, a large game studio (343 Industries), a small game studio (Starform), and now I&rsquo;m back at Xbox yet again working on emerging technologies. And on the side, I am working on a new indie game called &ldquo;Parchment&rdquo; - a 4X persistent world fantasy game.</p>
<h3 id="where-were-we">where were we?</h3>
<p>Oh yeah that&rsquo;s right, a new game server / multiplayer / netcode design. Well, if I&rsquo;m honest, I&rsquo;m not quite sure if it&rsquo;s new - I&rsquo;ve not been to every single game studio and asked them about their (probably secret) proprietary tech. It&rsquo;s likely more accurately described as a collection of patterns, practices and ideas from different systems I&rsquo;ve seen in the past 15+ years. I will be attempting to explain how it all works <em>generally</em>, without getting too technical, in the hopes of keeping a wider reading audience but also to keep some secret sauce for myself.</p>
<h2 id="simulations-that-arent-transient">simulations that aren&rsquo;t transient</h2>
<p>When you play a traditional RTS or 4X game, the world exists only while you’re in it. You log out, the simulation stops, and the universe blinks out of existence until you return. Parchment isn’t like that. Every realm keeps ticking — even when you’re offline — evolving under the stewardship of both human and AI civilizations.</p>
<p>Designing that kind of persistence meant building a server model closer to an MMO, but one tuned for asynchronous strategy, not 100% twitch combat.</p>
<h3 id="introducing-your-personal-bee">introducing your personal &ldquo;bee&rdquo;</h3>
<p>When you join a realm, your own personal &ldquo;bee&rdquo; spawns in the hive of bees. This bee takes in all of your requests, validates them, does most of the heavy compute work, and ensures all your input is handled sequentially or in order. It is not bothered by what the other bees are doing, and it will always go to a honeycomb that is least busy. (For the technical folks out there, this is the <a href="https://learn.microsoft.com/en-us/dotnet/orleans/overview">Orleans Grains/Silo technology</a>, aka Actor Model).</p>
<p>When the bee has finished a unit of work, it delivers it to the queen bee, who in turn distributes information about that unit of work to any others that care. In this way, the queen is in charge of the realm. This &ldquo;actor model&rdquo; concept isn&rsquo;t a new thing in the software industry, but something that&rsquo;s rather special about how I&rsquo;m doing it is how seemlessly and quickly it scales.</p>
<p><img src="/images/beeHiveServers.png" alt=""></p>
<p>As you can see, for any given realm that&rsquo;s running, the work is spread over multiple servers. This gives us several wins:</p>
<ol>
<li>A &ldquo;hot&rdquo; realm is never on one server alone. &ldquo;Cold&rdquo; realms automatically make space for the hot ones.</li>
<li>A simulation error or issue doesn&rsquo;t have to crash the realm, just your worker bee. Most game servers have one ferociously pumping update loop that any one single exception can bring the entire thing crashing down.</li>
<li>The primary &ldquo;update loop&rdquo; is automatically multi-threaded across several servers and doesn&rsquo;t have to be concerned with large compute or physics tasks like pathfinding or terrain generation.</li>
</ol>
<h3 id="multiplayer-games-are-classicly-very-chatty">multiplayer games are classicly very &ldquo;chatty&rdquo;</h3>
<p>The standard issue multiplayer dedicated server is noisy and busy. <em>Every single frame of the simulation</em> the server is sending updates about the game (typically game state or partial state updates) to every connected player. At a 20FPS simulation with 10 connected clients sending input, the server is sending/receiving hundreds (often thousands) of events over the network per second. Granted, this is a mediocre design scenario, many modern designs are better than this - but even the best ones are transmitting hundreds of updates per second for only ten players.</p>
<p>Rather than flooding the network with constant position updates like a shooter, Parchment communicates in orders, not transforms. For example, the client sends a “move to” command; the server validates, computes a path, and sends back waypoints. The client then interpolates locally and reconciles occasionally.</p>
<p>Bandwidth is tight and tidy. A single move command takes a fraction of what it would in a typical multiplayer persistent world server. World of Warcraft, for example, clocks in at 21KB/s per player average according to this <a href="https://lucris.lub.lu.se/ws/portalfiles/portal/5535189/2027067.pdf">academic source</a> (and that&rsquo;s fairly low). <em>Parchment will hopefully sit between 0.5KB/s or 1.5KB/s.</em></p>
<p>This opens up so many exciting possibilities:</p>
<ol>
<li>Parchment as a mobile game isn&rsquo;t going to frustrate players for consuming mobile data</li>
<li>More realms can fit onto a single server, drastically reducing costs to maintain realms. The current ambitious goal is to have a single server have the capability to serve 10,000 concurrent players (100x realms per server, 100 players per realm). Web servers can do this easily, but game servers&hellip; I rarely see a single game server (VM) that host more than 1000 players. (In fairness, some notable callouts that can include Minecraft, PlanetSide).</li>
</ol>
<h3 id="i-havent-even-covered-some-of-the-best-parts">I haven&rsquo;t even covered some of the best parts</h3>
<p>That&rsquo;s all for now&hellip; this blog is now getting a little long, so I&rsquo;ll save some of the more interesting parts for next time. (:</p>
<p>Next up:</p>
<ul>
<li>Keeping time in a persistent world</li>
<li>Fast-fowarding and parking</li>
<li>Snapshots &amp; per-realm upgrades</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
